#!/usr/bin/env node
const openai = require("openai");
const yaml = require("yaml");
const fs = require("fs/promises");
const oai = new openai.OpenAI();

async function main() {
  const dir = process.cwd();

  const force = process.argv[2] === "-f";

  const result = yaml.parseAllDocuments(await fs.readFile(`${dir}/kblock.yaml`, "utf8"));
  if (result.length !== 1) {
    throw new Error("Expected exactly one document in kblock.yaml");
  }

  const doc = result[0];
  const def = doc.get("definition");
  const engine = doc.get("engine");

  const readmeFile = def.get("readme");

  let readme;

  if (readmeFile && !force) {
    console.log(`README already exists: ${readmeFile} (use -f to force)`);
    readme = await fs.readFile(`${dir}/${readmeFile}`, "utf8");
  } else {
    switch (engine) {
      case "helm":
        readme = await generateDocsHelm(dir);
        break;

      case "wing/tf-aws":
      case "wing":
        readme = await generateDocsWing(dir);
        break

      case "tofu":
        readme = await generateDocsTofu(dir);
        break

      default:
        throw new Error(`Unknown engine: ${engine}`);
    }

    await fs.writeFile(`${dir}/README.md`, readme);
    def.set("readme", new yaml.Scalar("README.md"));  
  }


  if (!def.has("icon") || force) {
    const icon = await findHeroIcon(readme);
    def.set("icon", new yaml.Scalar(`heroicon://${icon}`));
  } else {
    console.log(`Icon already exists: ${def.get("icon")} (use -f to force)`);
  }

  await fs.writeFile(`${dir}/kblock.yaml`, yaml.stringify(doc));
}

async function findHeroIcon(readme) {
  const result = await oai.chat.completions.create({
    model: "gpt-4o",
    max_tokens: 10,
    messages: [
      { role: "system", content: "Suggest a hero icon (https://heroicons.com/) to represent the resource described in the readme. The output should only include the identifier of the hero icon ([a-z0-9\-]+). For example `arrow-down-on-square` without any wrapping information or quotes" },
      { role: "user", content: JSON.stringify({ readme }) },
    ]
  });

  return result.choices[0].message.content;
}

async function generateDocsWing(dir) {
  return generateReadme(dir, {
    method: "The resource is implemented by creating a Wing object by the name of <Kind> and synthesizing it into Kubernetes manifests.",
    values: "An instantiation of the <Kind> object, while passing the Kubernetes object desired state as the <Kind>Spec properties to the new object.",
    schema: {
      generateFrom: "The schema is generated by turn the <Kind>Spec in the code in a JSON schema. All fields are at the **root** of the resource, not under 'spec'.",
    },
    code: await readAll(dir, p => p.endsWith(".w")),
  });
}

async function generateDocsTofu(dir) {
  return generateReadme(dir, {
    method: "The resource is implemented by applying a terraform configuration.",
    values: "Terraform input variables that are referenced by the Terraform configuration.",
    schema: await fs.readFile(`${dir}/values.schema.json`, "utf8"),
    code: await readAll(dir, p => p.endsWith(".tf")),
  });

}

async function generateDocsHelm(dir) {
  return generateReadme(dir, {
    method: "The resource is implemented through a Helm chart, which is a collection of templates and values that can be used to generate Kubernetes manifests.",
    values: "helm 'values'",
    schema: await fs.readFile(`${dir}/values.schema.json`, "utf8"),
    code: await readAll(`${dir}/templates`),
  });
}

async function generateReadme(dir, options) {
  const prompt = {
    task: [
      "Generate a README.md file for this project based on the information provided in the context and the structure defined in this prompt.",
      "",
      "The project is a Kubernetes custom resource. ",
      "The context includes the following fields:",
      "`definition` - information about the names of the CRD (apiVersion, kind, etc).",
      "`schema` - instructions and information about how the CRD schema is defined (all fields are at the **root** of the resource, not under 'spec').",
      "`implementation` - information about how the resource is implemented and the various APIs that can be used to manage it.",
      "",
      "This resource then becomes a native Kubernetes object that can be managed using the standard Kubernetes API, such as kubectl, kustomize or helm charts or any other type of Kubernetes manifest.",
      options.method,
      `Once the resource is applied to the cluster, the Kblocks controller will reconcile the state of the cluster with the desired state by converting the object into ${options.values}`,
      "The resources created will be associated with the parent custom resource and tracked by it.",
      "The output should be standard readme markdown file based on the 'template' defined in the system instructions."
    ],

    template: [
      "# Resource Name (based on the 'Kind' of the resource)",
      "<one short sentence description of the resource>",
      "## Usage",
      "<2-3 examples of Kubernetes YAMLs that creates an instance of the resource for various use cases. Do not include a 'spec' property unless the CRD schema defines it explicitly!>",
      "## Configuration",
      "<a description of the fields in the CRD and their default values>",
      "## Outputs (if applicable)",
      "<do not include this section if 'definition' does not have an 'outputs' field>",
      "<a description of the outputs of the resource (as defined in the 'definition.outputs' of the context), if it creates any child resources>",
      "These fields will be available under the `status` subresource of the custom resource and can be also referenced from other kblocks through `${ref://<kind>.<group>/<name>/<field>}`",
      "## Resources",
      "<a list of explicit kubernetes child resources and their names which created by the custom resource>",
      "## Behavior",
      `<a description of the behavior of the resource, based ${options.method}>`,
    ],

    example_template: [
      "### Example: <name>",
      "<description of the example>",
      "",
      "```yaml",
      "apiVersion: <apiVersion>",
      "kind: <Kind>",
      "metadata:",
      "  name: <name>",
      "",
      "<field1>: <value1>",
      "<field2>: <value2>",
      "<field2>: <value2>",
      "```",
    ],
  };

  const context = {
    definition: await fs.readFile(`${dir}/kblock.yaml`, "utf8"),
    schema: options.schema,
    implementation: options.code,
  };

  console.log("Generating README.md for project in", dir);
  const result = await oai.chat.completions.create({
    model: "gpt-4o",
    max_tokens: 2048,
    messages: [
      { role: "system", content: JSON.stringify({ prompt }) },
      { role: "user", content: JSON.stringify({ context }) },
    ],
  });

  return result.choices[0].message.content;
}

async function readAll(base, filter) {
  const output = {};

  const readDir = async dir => {

    for (const f of await fs.readdir(`${base}/${dir}`)) {
      const relpath = `${dir}/${f}`;
      const fullpath = `${base}/${relpath}`;

      const stat = await fs.stat(fullpath);
      if (stat.isDirectory()) {
        await readAll(fullpath);
      } else {
        if (filter && !filter(relpath)) {
          continue;
        }

        const c = await fs.readFile(fullpath, "utf8");
        output[relpath] = c;
      }
    }
  
  };

  await readDir(".");

  return output;
}

main().catch(e => {
  console.error(e);
  process.exit(1);
});

