import openai from "openai";
import yaml from "yaml";
import fs from "fs/promises";
import { readAll } from "./util";
import path from "path";
import { Manifest } from "./types";

interface DocsOptions {
  readonly path: string;
  readonly force?: boolean;
}

export async function docs(options: DocsOptions) {
  const dir = path.resolve(options.path);
  const result = yaml.parseAllDocuments(await fs.readFile(`${dir}/kblock.yaml`, "utf8"));
  if (result.length !== 1) {
    throw new Error("Expected exactly one document in kblock.yaml");
  }

  const force = options.force ?? false;
  const doc = result[0];
  const def = doc.get("definition");

  if (!yaml.isMap(def)) {
    throw new Error("definition is not a map");
  }

  const engine = doc.get("engine") as Manifest["engine"];

  const readmeFile = def.get("readme");

  let readme: string;

  if (readmeFile && !force) {
    readme = await fs.readFile(`${dir}/${readmeFile}`, "utf8");
  } else {
    switch (engine) {
      case "helm":
        readme = await generateDocsHelm(dir);
        break;

      case "wing/tf-aws":
      case "wing":
        readme = await generateDocsWing(dir);
        break

      case "tofu":
        readme = await generateDocsTofu(dir);
        break

      default:
        throw new Error(`Unknown engine: ${engine}`);
    }

    await fs.writeFile(`${dir}/README.md`, readme);
    def.set("readme", new yaml.Scalar("README.md"));  
  }


  if (!def.has("icon") || force) {
    const icon = await findHeroIcon(readme);
    def.set("icon", new yaml.Scalar(`heroicon://${icon}`));
  }

  await fs.writeFile(`${dir}/kblock.yaml`, yaml.stringify(doc));
}

async function findHeroIcon(readme: string) {
  const oai = new openai.OpenAI();
  const result = await oai.chat.completions.create({
    model: "gpt-4o",
    max_tokens: 10,
    messages: [
      { role: "system", content: "Suggest a hero icon (https://heroicons.com/) to represent the resource described in the readme. The output should only include the identifier of the hero icon ([a-z0-9-]+). For example `arrow-down-on-square` without any wrapping information or quotes" },
      { role: "user", content: JSON.stringify({ readme }) },
    ]
  });

  return result.choices[0].message.content;
}

async function generateDocsWing(dir: string) {
  return generateReadme(dir, {
    method: "The resource is implemented by creating a Wing object by the name of <Kind> and synthesizing it into Kubernetes manifests.",
    values: "An instantiation of the <Kind> object, while passing the Kubernetes object desired state as the <Kind>Spec properties to the new object.",
    schema: {
      generateFrom: "The schema is generated by turn the <Kind>Spec in the code in a JSON schema. All fields are at the **root** of the resource, not under 'spec'.",
    },
    code: await readAll(dir, p => p.endsWith(".w")),
  });
}

async function generateDocsTofu(dir: string) {
  return generateReadme(dir, {
    method: "The resource is implemented by applying a terraform configuration.",
    values: "Terraform input variables that are referenced by the Terraform configuration.",
    schema: JSON.parse(await fs.readFile(`${dir}/values.schema.json`, "utf8")),
    code: await readAll(dir, p => p.endsWith(".tf")),
  });

}

async function generateDocsHelm(dir: string) {
  return generateReadme(dir, {
    method: "The resource is implemented through a Helm chart, which is a collection of templates and values that can be used to generate Kubernetes manifests.",
    values: "helm 'values'",
    schema: await fs.readFile(`${dir}/values.schema.json`, "utf8"),
    code: await readAll(`${dir}/templates`),
  });
}

interface Options {
  readonly method: string;
  readonly values: string;
  readonly schema: any;
  readonly code: Record<string, string>;
}

async function generateReadme(dir: string, options: Options): Promise<string> {
  const prompt = {
    task: [
      "Generate a README.md file for this project based on the information provided in the context and the structure defined in this prompt.",
      "",
      "The project is a Kubernetes custom resource. ",
      "The context includes the following fields:",
      "`definition` - information about the names of the CRD (apiVersion, kind, etc).",
      "`schema` - instructions and information about how the CRD schema is defined (all fields are at the **root** of the resource, not under 'spec').",
      "`implementation` - information about how the resource is implemented and the various APIs that can be used to manage it.",
      "",
      "This resource then becomes a native Kubernetes object that can be managed using the standard Kubernetes API, such as kubectl, kustomize or helm charts or any other type of Kubernetes manifest.",
      options.method,
      `Once the resource is applied to the cluster, the Kblocks controller will reconcile the state of the cluster with the desired state by converting the object into ${options.values}`,
      "The resources created will be associated with the parent custom resource and tracked by it.",
      "The output should be standard readme markdown file based on the 'template' defined in the system instructions."
    ],

    template: [
      "# Resource Name (based on the 'Kind' of the resource)",
      "<one short sentence description of the resource>",
      "## Usage",
      "<2-3 examples of Kubernetes YAMLs that creates an instance of the resource for various use cases. Do not include a 'spec' property unless the CRD schema defines it explicitly!>",
      "## Configuration",
      "<a description of the fields in the CRD and their default values>",
      "## Outputs (if applicable)",
      "<do not include this section if 'definition' does not have an 'outputs' field>",
      "<a description of the outputs of the resource (as defined in the 'definition.outputs' of the context), if it creates any child resources>",
      "These fields will be available under the `status` subresource of the custom resource and can be also referenced from other kblocks through `${ref://<kind>.<group>/<name>/<field>}`",
      "## Resources",
      "<a list of explicit kubernetes child resources and their names which created by the custom resource>",
      "## Behavior",
      `<a description of the behavior of the resource, based ${options.method}>`,
    ],

    example_template: [
      "### Example: <name>",
      "<description of the example>",
      "",
      "```yaml",
      "apiVersion: <apiVersion>",
      "kind: <Kind>",
      "metadata:",
      "  name: <name>",
      "",
      "<field1>: <value1>",
      "<field2>: <value2>",
      "<field2>: <value2>",
      "```",
    ],
  };

  const context = {
    definition: await fs.readFile(`${dir}/kblock.yaml`, "utf8"),
    schema: options.schema,
    implementation: options.code,
  };

  console.log("Generating README.md for project in", dir);
  const oai = new openai.OpenAI();
  const result = await oai.chat.completions.create({
    model: "gpt-4o",
    max_tokens: 2048,
    messages: [
      { role: "system", content: JSON.stringify({ prompt }) },
      { role: "user", content: JSON.stringify({ context }) },
    ],
  });

  if (!result.choices[0].message.content) {
    throw new Error("Failed to generate README.md");
  }

  return result.choices[0].message.content;
}

